/**
\page loggermechanisms GCF Logging Mechanisms

Qt offers qDebug(), qWarning(), qCritical() and qFatal() to log messages
from Qt programs. It provides a qInstallMsgHandler() to redirect messages
generated by the above functions into any file or console. Although this is
good, it is not sufficient for some purposes.

Most applications out there maintain a log file into which the application
constantly dumps run-time information. Incase the user runs into any
issues within the application; he can always send the log file to the vendor
and have a solution figured out.

From Version 2.2 onwards, GCF offers an exhaustive mechanism to log messages.
The design of the \ref logger module in GCF is based on log4cxx project
from Apache (http://logging.apache.org/log4cxx/index.html). Our initial
idea was to take log4cxx and provide GCF/Qt interfaces to it. Later on we
thought of simply providing a lightweight Qt only logging mechanism within
GCF.

The Logger module in GCF consists of 4 main classes
\li \ref GCF::Logger - The main logger class
\li \ref GCF::Log - Logging is done through instances of this class
\li \ref GCF::AbstractLogBackend - Log messages are eventually dumped into instances
of this class
\li \ref GCF::AbstractLogLayout - Log messages are formatted using instances of these
classes.

Log messages are generated by making use of any one of the macros below

\li GCF_DEBUG( Log, Msg )
\li GCF_ERROR( Log, Msg )
\li GCF_WARNING( Log, Msg )
\li GCF_FATAL( Log, Msg )
\li GCF_LOG( Log, Msg )

The logger module has the following key concepts

\li GCF::Logger is the book-keeper and factory for logger objects
\li A log (instance of GCF::Log) can be created using GCF::Logger::log() method
against a {context, backend, layout} triplet. Multiple calls to log() with the
same context name returns the same log object.
\li GCF::Log provides methods to log debug, error, critical and fatal messages.
It makes use of a GCF::AbstractLogLayout instance to format messages before
dumping the message into a GCF::AbstractLogBackend instance.

The logger module provides the following backends by default
\li GCF::LogFileBackend - instances can be created using the GCF::Logger::fileBackend() method
\li GCF::LogConsoleBackend - the only instance can be fetched using GCF::Logger::consoleBackend() method
\li GCF::LogQtMsgBackend - the only instance can be fetched using GCF::Logger::qtMsgBackend() method

The logger module provides the following layouts by default
\li GCF::LogSimpleLayout - Formats messages as "Simple Context: [DEBUG] Debug message"
\li GCF::LogDateLayout - Formats messages as "Wed Apr 8 10:16:51 2009 - Date Context: [DEBUG] Debug message"
\li GCF::LogHtmlLayout - Dumps logs into a HTML file
\li GCF::LogXmlLayout - Dumps logs into a XML file

The best way to understand this module is to actually look at a working example(s).

\section logger1 Logging to the console

\code
#include <GCF/Logger>

int main()
{
    // By default the GCF::Logger::log() method returns a log
    // that uses a console backend with a simple layout.
    GCF::Log* consoleLog = GCF::Logger::instance().log("Simple Context");

    GCF_DEBUG(consoleLog, "Debug message");
    GCF_ERROR(consoleLog, "Error message");
    GCF_WARNING(consoleLog, "Warning message");
    GCF_FATAL(consoleLog, "Fatal message");
    GCF_LOG(consoleLog, "Log message");

    // GCF::Logger takes care of deleting consoleLog.
    return 0;
}
\endcode

\section logger2 Logging to simple text file

\code
#include <GCF/Logger>

int main()
{
    // We want to dump log messages into a file
    GCF::AbstractLogBackend* file1 = GCF::Logger::instance().fileBackend("Simple.txt");

    // Log messages should have a simple layout
    GCF::AbstractLogLayout* simpleLayout = GCF::Logger::instance().simpleLayout();

    // Catch hold of an object that does logging
    GCF::Log* simpleLog = GCF::Logger::instance().log("Simple Context", file1, simpleLayout);

    // Log messages one after the other
    GCF_DEBUG(simpleLog, "Debug message");
    GCF_ERROR(simpleLog, "Error message");
    GCF_WARNING(simpleLog, "Warning message");
    GCF_FATAL(simpleLog, "Fatal message");
    GCF_LOG(simpleLog, "Log message");

    // GCF::Logger takes care of deleting file1, simpleLayout, simpleLog, etc..
    // Basically it releases all logger resources.
    return 0;
}
\endcode

\section logger3 Logging to a HTML file

\code
#include <GCF/Logger>

int main()
{
    // We want to dump log messages into a file
    GCF::AbstractLogBackend* file1 = GCF::Logger::instance().fileBackend("Log.html");

    // Log messages should have a HTML layout
    GCF::AbstractLogLayout* htmlLayout = GCF::Logger::instance().htmlLayout();

    // Catch hold of an object that does logging
    GCF::Log* htmlLog = GCF::Logger::instance().log("Simple Context", file1, htmlLayout);

    // Log messages one after the other
    GCF_DEBUG(htmlLog, "Debug message");
    GCF_ERROR(htmlLog, "Error message");
    GCF_WARNING(htmlLog, "Warning message");
    GCF_FATAL(htmlLog, "Fatal message");
    GCF_LOG(htmlLog, "Log message");

    return 0;
}
\endcode

\section logger4 Logging to both file and console

\code
#include <GCF/Logger>

int main()
{
    GCF::AbstractLogBackend* file1 = GCF::Logger::instance().fileBackend("Simple.txt");
    GCF::AbstractLogLayout* simpleLayout = GCF::Logger::instance().simpleLayout();
    GCF::Log* simpleLog = GCF::Logger::instance().log("Simple Context", file1, simpleLayout);

    // ------
    // Have simpleLog write to the console as well
    // ------
    simpleLog->addBackend( GCF::Logger::instance().consoleBackend() );

    GCF_DEBUG(simpleLog, "Debug message");
    GCF_ERROR(simpleLog, "Error message");
    GCF_WARNING(simpleLog, "Warning message");
    GCF_FATAL(simpleLog, "Fatal message");
    GCF_LOG(simpleLog, "Log message");

    return 0;
}
\endcode

\section logger5 Logging to multiple files in different formats

\code
#include <GCF/Logger>

int main()
{
    
    // Create a log that will primary write into Simple.txt, using a simple layout.
    GCF::Log* log = GCF::Logger::instance().log(
                         "Simple Context", 
                         GCF::Logger::instance().fileBackend("Simple.txt")
                         GCF::Logger::instance().simpleLayout()
                     );
    
    // Now have the same log write to Log.html in HTML layout
    log->addBackend( GCF::Logger::instance().fileBackend("Log.html"),
                     GCF::Logger::instance().htmlLayout() );
    
    // Now have the same log write to the console in Date Layout
    log->addBackend( GCF::Logger::instance().consoleBackend(), 
                     GCF::Logger::instance().dateLayout() );

    // The following messages will show up in Simple.txt, Log.html and the console
    // in their respective formats.
    GCF_DEBUG(log, "Debug message");
    GCF_ERROR(log, "Error message");
    GCF_WARNING(log, "Warning message");
    GCF_FATAL(log, "Fatal message");
    GCF_LOG(log, "Log message");

    // GCF::Logger takes care of deleting log, file backends for Simple.txt
    // and Log.html and layouts.
    return 0;
}
\endcode

\section logger6 Using the default logger

The GCF::Application class creates its own log file by default. You can append your logs into this log file
by making use the log methods in the GCF::Application class.

\code
#include <GCF/Application>

gApp->log("Log message");
gApp->debugLog("Debug message");
gApp->errorLog("Error message");
gApp->warningLog("Warning message");
gApp->fatalLog("Fatal message");
\endcode

By default the GCF::Application creates a \c .txt file whose name is same as \c GCF::Application::applicationName() 
and uses a date-layout to format log messages dumped into the file. You can set your own log file by making use
the following code snippent, much before the very first log message is dumped into the log file. This means the following
code should typically be done in the \c main() function and much before any component is registered and initialized.

\code
int main(int argc, char** argv)
{
	GCF::Application a(argc, argv);
	
	GCF::Log* log = .....;
	a.setLogObject( log );
	
	// ...
	
	return a.exec();
}
\endcode

*/

